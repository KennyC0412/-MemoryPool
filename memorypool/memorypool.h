#pragma once
#ifndef _MEMORYPOOL_H_
#define _MEMORYPOOL_H_
#include <cstdlib>


#ifdef _DEBUG
#include <iostream>
	#define xCout std::cout
#else
	#define xCout(...)
#endif

const int MAX_MEMORY_SIZE = 64;

class MemoryAlloc;

//内存块
class MemoryBlock
{
public:
	//内存块编号
	int nID;
	//引用次数
	int nRef;
	//所属内存块（池）
	MemoryAlloc* pAlloc;
	//下一块位置
	MemoryBlock* pNext;
	//是否在内存池中
	bool inPool;
};

//内存池
class MemoryAlloc
{
public:
	MemoryAlloc() :pBuf(nullptr), pHead(nullptr){ }
	~MemoryAlloc()
	{
		if (pBuf)
			free(pBuf);
	}	
	//初始化
	void initMem();
	//申请内存
	void* allocMem(size_t);
	//释放内存
	void freeMem(void*);
protected:
	//内存池地址
	char* pBuf;
	//内存池头部指针
	MemoryBlock* pHead;
	//内存单元大小
	size_t nSize;
	//内存单元数量
	size_t nBlockSize;
};

template<size_t nsize,size_t nblockSize>
class MemoryAllocator : public MemoryAlloc
{
public:
	MemoryAllocator() {
		const int size = sizeof(void*);
		nSize = (nsize / size) * size + (nsize % size ? size:0 );
		nBlockSize = nblockSize;
		//initMem();
	}
};

//内存管理工具
class MemoryManage
{
public:
	//单例
	static MemoryManage& getInstance();
	//申请内存
	void *allocMem(size_t);
	//释放内存
	void freeMem(void*);
private:
	//将构造方法声明为私有
	MemoryManage(){
		init(0, 64, &mem64);
	}
	~MemoryManage(){}
	MemoryManage(MemoryManage&) = delete;//删除拷贝构造函数
	MemoryManage& operator=(MemoryManage&) = delete;//删除复制运算符
private:
	//内存池映射数组初始化
	void init(int, int, MemoryAlloc *);
	MemoryAllocator<64, 12> mem64;
	MemoryAlloc* szAlloc[MAX_MEMORY_SIZE + 1];
};
#endif